<!DOCTYPE html>
<html>
	<head>
		<title>World Hearth</title>

		<meta charset="utf-8">
		<style>

			body {
				background-color: black;
			}

		</style>
	</head>

	<body onload="gameLoop()">
		<script>
//Start config options
		var pixelScale = 3;
		var bgColor = "#d7e894";
		var inputState = {
			aButton : [false, "done"],
			bButton : [false, "done"],
			lButton : [false, "done"],
			rButton : [false, "done"],
			uButton : [false, "done"],
			wButton : [false, "done"],
			zbugUp : [false, "done"],
			z2bugDown : [false, "done"],
			z3bugExit : [false, "done"],
			z4bugSpecial : [false, "done"]
		};
		var inputKeys = {
			aButton : "z", //Z by Default
			bButton : "x", //X by default
			lButton : "ArrowLeft", //Left Arrow Key
			rButton : "ArrowRight", //Right Arrow Key
			uButton : "ArrowUp", //Up Arrow Key
			wButton : "ArrowDown", //Down Arrow Key				
			zbugUp : "9",
			z2bugDown : "0",
			z3bugExit : "`",
			z4bugSpecial : "Control"
		};
		var trayImg = new Image();
		trayImg.src = "tray.png";
		var img = new Image();   // Create new img element	
		var blockSize = 18;
		var traySize = blockSize - 1;			
		var globalInv = [];
		var localInv = [];
		var itemLog = [];
		var insertPoint = 0;
		var insertSpeed = 2;
		var hitBoxHold = {};
		var hitCheckHold = {};



		var debugInc = 0

//End config options

//DEBUG TOOLS
		var stop = false;
		var frameCount = 0;
		var now = performance.now();
		var debugMode = false;
		var deltaFr = 0;
		var deltaTime = performance.now();
		var frameBefore = 0;

		function carpenter(couch) {
			couch = globalInv[couch];

			if (inputState.rButton[1] == "held" && inputState.lButton[1] == "held") {
				//Blank on purpose
			}
			else if (inputState.rButton[1] == "held") {
				couch.xPos += 1;
			}
			else if (inputState.lButton[1] == "held") {
				couch.xPos -= 1;
			}


			if (inputState.wButton[1] == "held" && inputState.uButton[1] == "held") {
				//Blank on purpose
			}
			else if (inputState.wButton[1] == "held") {
				couch.yPos += 1;
			}
			else if (inputState.uButton[1] == "held") {
				couch.yPos -= 1;
			}
		}
//

//Start canvas delerations
		var canvas = document.createElement("canvas");
		canvas.id = "gameCanvas";
		canvas.width = 160 * pixelScale;
		canvas.height = 144 * pixelScale;
		canvas.style.position = "center";
		canvas.style.background = "white";
		canvas.style.position = "relative";
		canvas.style.left = (window.innerWidth/2 - canvas.width/2) +"px"; 
		canvas.style.top = (window.innerHeight/2 - canvas.height/2) + "px";

		var ctxGame = canvas.getContext("2d");
		ctxGame.imageSmoothingEnabled = false;

		ctxGame.font = (10 * pixelScale) + "px Arial";

		var body = document.getElementsByTagName("body")[0];
		body.appendChild(canvas);
//End canvas declarations

//Start Input Functions

		document.addEventListener("keydown", inputHandler, false);
		document.addEventListener("keyup", inputHandler, false);
		canvas.addEventListener("mousedown", rebindControls, false);
		//document.addEventListener("keypress", inputHandler, false);
		
		function inputHandler(event){
			for(var input in inputKeys){
				if (inputKeys[input] == event.key) {
					inputState[input][0] = event.type == 'keydown';
				}
				if (inputState[input] == "rebinding" && event.type == 'keyup') {
					inputKeys[input] = event.key;
					inputState[input] = [false, "done"];
					break;
				}
			}
			

			if (event.key == inputKeys["z3bugExit"] && event.type == 'keyup') {
				debugMode = !debugMode;
			}
		}

		function inputProcess(){
			for (var press in inputState) {
				if (inputState[press][0] && inputState[press][1] == "done") {
					inputState[press][1] = "tap";
				}
				else if (inputState[press][0] && inputState[press][1] == "tap") {
					inputState[press][1] = "held";
				}
				else if (!inputState[press][0]) {
					inputState[press][1] = "done";
				}
			}
		}

		function rebindControls() {
			debugMode = true;

			for (var remap in inputState) {
				inputState[remap] = "rebinding";
				inputKeys[remap] = "[?]";				
			}
		}

		function playerAction() {
			if (!debugMode) {
				if (inputState.lButton[1] == "tap" && insertPoint > 0) {
					insertPoint--;
				}

				if (inputState.rButton[1] == "tap" && insertPoint < Math.floor(globalInv[0].width / traySize) - 1) {
					insertPoint++;
				}

				if (inputState.z4bugSpecial[1] == "tap") {
					if (debugInc + 1 <= itemLog.length - 1) {
						debugInc++;
					}
					else if (debugInc + 1 > itemLog.length - 1)
						debugInc = 0;

					globalInv[0].temperature++;
				}

				if (inputState.uButton[1] == "tap") { //&& globalInv[0].capacity > globalInv[0].contents.length) {
				//           (itemIdx, targInv, isVert)
					insertInventory(debugInc, 0, true);
				}

				if (inputState.wButton[1] == "tap" && 0 < globalInv[0].contents.length) {
					for (var p = 0; p < globalInv[0].contents.length; p++) {
						if (globalInv[0].contents[globalInv[0].contents.length - p - 1][insertPoint] != 0) {

							globalInv[0].contents[globalInv[0].contents.length - p - 1][insertPoint] = 0;
							break;

						}
					}					
				}
			}
		}
//End Input Functions

//Sprite Cutting Functions
		var testImg = new Image();
		testImg.src = "pot.png";

		var junkImg = new Image();
		junkImg.src = "junk2.png";

		var bunnImg = new Image();
		bunnImg.src = "dustbunny.png";

		var cornImg = new Image();
		cornImg.src = "popcorn.png";

		var imp1Img = new Image();
		imp1Img.src = "imp1.png";
//End Sprite Cutting Functions

//Items and inventory functions

		function Inventory(name, sprite, xPos, yPos, width, height, heatFactor, temperature, anchor, anchorMod){
			this.name = name || "NO NAME";
			this.sprite = sprite || "NO IMAGE";
			this.heatFactor = (heatFactor * 1.0) || 1;
			this.temperature = (temperature * 1.0) || 0;
			this.xPos = xPos || 0;
			this.yPos = yPos || 0;
			this.xCrunch = 0;
			this.yCrunch = 0;
			this.width = width || 0;
			this.height = height || 0;
			this.anchorMod = anchorMod || [0,0];
			this.anchor = [anchor[0] + anchorMod[0], anchor[1] + anchorMod[1] - height / 2];
			this.contents = generateInv(this.height, this.width);
			//console.log("INVENTORY OBJECT LOADED");
		} 

		function generateInv (height, width) { 
			var pndInv = [];
			for (var rw = 0; rw < height / blockSize; rw++) {
				pndInv.push([]);

				for (var clm = 0; clm < width / blockSize; clm++) {	
					pndInv[rw].push(0);
				}	
			}

						//console.log("INVENTORY MATRIX READY");
			return pndInv;	
		}
		
		function Item(name, sprite, type, currCook, maxCook) {
			this.name = name || "???";
			this.type = type || "NULL";
			this.sprite = sprite || trayImg;
			this.currCook = currCook || 0;
			this.maxCook = maxCook || 0;
			this.xPos = 0;
			this.yPos = 0;
			this.xSpeed = 0;
			this.ySpeed = 0;
			this.InvEffect = 0;
			this.HrtEffect = 0;
			this.BllwEffect = 0;
			this.ThrEffect = 0;

			//console.log("ITEM OBJECT GOOD TO GO");
		}

		function drawItems() {
			for (var box in globalInv) {

				if (globalInv[box].contents.length <= 0) {
					break;
				}

				for (var i = 0; i < globalInv[box].contents.length; i++) {
					for (var v = 0; v < globalInv[box].contents[i].length; v++) {
						if (globalInv[box].contents[i][v] != 0) {
							scaleImg(
								globalInv[box].contents[i][v].sprite,
								globalInv[box].contents[i][v].xPos + globalInv[box].xPos,
								globalInv[box].contents[i][v].yPos	+ globalInv[box].yPos				
							);
						}
					}
				}
			}

			//console.log("DRAWING ITEMS!");
		}


		function drawHeat(inv) {		
			var percent = inv.temperature / inv.heatFactor;
			var multiplier = 1;

			while (percent >= 1) {
				percent = percent - 1;
				multiplier++;
			}

			var meterHeight = inv.height * percent;
			var barY = inv.yPos - blockSize + 6;
			var barX = inv.xPos - blockSize / 2;
			var barWidth = blockSize / 4	;

			scaleText(multiplier + "x", barX - blockSize, barY + inv.height)

			//scaleRect(rectX, rectY, recWid, recHgt)
			scaleRect(
				barX, 
				barY, 
				barWidth, 
				inv.height
			);

			scaleRect(
				barX, 
				barY + inv.height - meterHeight, 
				barWidth, 
				meterHeight,
				true
			);

		}


		function drawInventories() {
			for (var inv in globalInv) {

				//scaleImg(globalInv[inv].sprite, globalInv[inv].xPos, globalInv[inv].yPos);
					//console.log("DRAWING INVENTORY SPRITE");
				scaleRect(
					globalInv[inv].anchor[0] + globalInv[inv].anchorMod[0] + globalInv[inv].xPos, //- (globalInv[inv].width / 2),
					globalInv[inv].anchor[1] + globalInv[inv].anchorMod[1] + globalInv[inv].yPos, //- (globalInv[inv].height / 2),
					globalInv[inv].width - globalInv[inv].xCrunch, 
					globalInv[inv].height - globalInv[inv].yCrunch
				);

					//console.log("DRAWING RECTANGLE");
			}
			//Draw block selection cursor
			scaleRect(
				globalInv[inv].anchor[0] + globalInv[inv].anchorMod[0] + globalInv[inv].xPos + insertPoint * blockSize, 
				globalInv[inv].anchor[1] + globalInv[inv].anchorMod[1] + globalInv[inv].yPos + globalInv[inv].height + 5, 
				traySize, 
				traySize
			);
		}


		function itemPhysics() {
			hitBoxHold = -1;
			hitCheckHold = -1;

			for (var invs = 0; invs < globalInv.length; invs++) {	//Traverse all inventories
				for (var y = 0; y < globalInv[invs].contents.length; y++) {	//Traverse all blocks in a single inventory
					for (var x = 0; x < globalInv[invs].contents[y].length; x++) {	

						if (debugMode) { //Print contents of inventory outside of debug mode to avoid messiness
							ctxGame.strokeStyle ="#000000";
							ctxGame.fillStyle = "#000000";
							ctxGame.fillText("[" + (globalInv[invs].contents[y][x].xPos || "??") + ", " + (globalInv[invs].contents[y][x].yPos || "??") + "]", scalePx(x + x * 20 * 2), scalePx(10 + y * 8));
						}

						//Check if object is a valid block and that it is moving
						if (globalInv[invs].contents[y][x] != 0 && globalInv[invs].contents[y][x].ySpeed != 0) {

							//If the block touches the top of the inventory (y-coordinate) OR another block, set block speed to 0
							if (globalInv[invs].contents[y][x].yPos <= globalInv[invs].anchor[1] ||
								(y - 1 >= 0 &&		
								globalInv[invs].contents[y][x].yPos <= globalInv[invs].contents[y - 1][x].yPos + blockSize &&
								globalInv[invs].contents[y][x] != globalInv[invs].contents[y][x])) 
							{
								globalInv[invs].contents[y][x].ySpeed = 0;
								console.log("BOP")
							}

							//If contact is made another block, move block one pixel away until the collission is resolved
							if (y - 1 >= 0) {
								while (globalInv[invs].contents[y][x].yPos <= globalInv[invs].contents[y - 1][x].yPos + blockSize &&
									   globalInv[invs].contents[y][x] == globalInv[invs].contents[y][x]
								) {

									globalInv[invs].contents[y][x].yPos += 1;
									/* console.log("Square NEW: " + globalInv[invs].contents[y][x].xPos + ", " + globalInv[invs].contents[y][x].yPos);
									console.log("Square OLD: " + globalInv[invs].contents[y - 1][x].xPos + ", " + globalInv[invs].contents[y - 1][x].yPos);*/

									}
								}
						}
							//If something's moving, move it to the correct distance according to its speed
							globalInv[invs].contents[y][x].yPos += globalInv[invs].contents[y][x].ySpeed;

					}

				}
			}
		}
					

		function insertInventory(itemIdx, targInv, isVert){			
			var newBlock = Object.assign({}, itemLog[itemIdx]);
			//var newBlock = new itemLog[itemIdx]
			targInv = globalInv[targInv];
			isVert = isVert || false;

			newBlock.xPos = targInv.anchor[0] + (traySize * insertPoint);
			newBlock.yPos = canvas.height / pixelScale - blockSize * 2 - targInv.yPos + targInv.anchor[1]; //targInv.sprite.height;

			if (isVert) {
				newBlock.xSpeed = 0;
				newBlock.ySpeed = -insertSpeed;				
			}
			else {				
				newBlock.xSpeed = insertSpeed;
				newBlock.ySpeed = 0;
			}

			for (var ins = 0; ins < targInv.contents.length; ins++) {
				if (targInv.contents[ins][insertPoint] == 0) {
					targInv.contents[ins][insertPoint] = newBlock;
					break;
				}
			}	
			//console.log("ADDING TO INVENTORY");		
		}
//End item/inventory objects/functions

//Screen Functions
		function scalePx(dim){
			return (pixelScale * dim);
		}

		function scaleImg(spr, sprX, sprY){
			ctxGame.drawImage(spr, scalePx(sprX), scalePx(sprY), scalePx(spr.width), scalePx(spr.height));
		}

		function scaleRect(rectX, rectY, recWid, recHgt, doFill) {
			if (doFill) {
				ctxGame.fillRect(scalePx(rectX), scalePx(rectY), scalePx(recWid), scalePx(recHgt));
			}
			else {
				ctxGame.strokeRect(scalePx(rectX), scalePx(rectY), scalePx(recWid), scalePx(recHgt));
			}

			//console.log("RECTANGLE DRAWN: With FILL: " + ctxGame.fillStyle + " and STROKE: " + ctxGame.strokeStyle);
		}

		function scaleText(text, posX, posY) {
			ctxGame.fillText(text, scalePx(posX), scalePx(posY));
		}


		function clearScreen(){
			ctxGame.fillStyle = bgColor;
			ctxGame.fillRect(0, 0, canvas.width, canvas.height);

			canvas.style.left = (window.innerWidth/2 - canvas.width/2) +"px"; 
			canvas.style.top = (window.innerHeight/2 - canvas.height/2) + "px";
			ctxGame.strokeStyle ="#000000";
			ctxGame.fillStyle = "#000000";
			ctxGame.imageSmoothingEnabled = false; 

			/* ctxGame.beginPath();
				ctxGame.moveTo(canvas.width / 2, 0);
				ctxGame.lineTo(canvas.width /2, canvas.height);
				ctxGame.stroke(); */


		}

		function changeScale(){
			var modifier = 0;

			if (inputState["zbugUp"][1] == "tap"){
				modifier = 1;
			}
			if (inputState["z2bugDown"][1] == "tap") {
				modifier = -1;
			}

			pixelScale += modifier;

			if (pixelScale <= 0) {
				pixelScale = 1;
			}

			canvas.width = 160 * pixelScale;
			canvas.height = 144 * pixelScale;
			ctxGame.font = (10 * pixelScale) + "px Arial"; 
		}
//End screen functions

//Gameplay Mechanic Methods

	function heatCheck(inv) {
		for (var row in inv.contents) {
			for (var col in inv.contents[row]){}

		}


	}



//End of game mechanics

//Last minute initializations
	//		  function Inventory(  name,  sprite, xPos, yPos, width,       height,       heatFactor, temperature, anchor, anchorMod){
	globalInv.push(new Inventory("Hearth", testImg, 48, 40, blockSize * 3, blockSize * 3,    100,          0,       [9, 19], [-2, -2]));

	//      Item(name, 		sprite, 	type, currCook, maxCook)
	itemLog = [
		new Item("Junk",    junkImg, 	"bad",	"0", 	"50"),
		new Item("Imp",     imp1Img, 	"bad", 	"0", 	"6.6"),
		new Item("Dstbuni",	bunnImg, 	"bad", 	"0", 	"5"),
		new Item("Popcrn", 	cornImg, 	"meh", 	"0", 	"20")


	];
//End of last calls


	function gameLoop(){
		now = performance.now();

		if (now - deltaTime > 1000) {
			deltaFr = frameCount - frameBefore;
			frameBefore = frameCount;
			deltaTime = now;
		}



		if (!stop) {
			frameCount++;

			changeScale();
			clearScreen();
			inputProcess();
			playerAction();


			itemPhysics();
			drawInventories();
			drawItems();
			drawHeat(globalInv[0]);

			if (debugMode) {
			
				carpenter(0);

				//ctxGame.strokeStyle ="#000000";
				//ctxGame.fillStyle = "#000000";

				//ctxGame.fillText("X: " + globalInv[0].xPos + " Y: " + globalInv[0].yPos, 
				//					scalePx(globalInv[0].xPos), 
				//					scalePx(globalInv[0].yPos)
				//				);

				ctxGame.fillText("[A]: "         + inputState["aButton"] + " >" + inputKeys["aButton"], scalePx(10), scalePx(30));
				ctxGame.fillText("[B]: "         + inputState["bButton"] + " >" + inputKeys["bButton"], scalePx(10), scalePx(40));
				ctxGame.fillText("[Left]: "      + inputState["lButton"] + " >" + inputKeys["lButton"], scalePx(10), scalePx(50));
				ctxGame.fillText("[Right]: "     + inputState["rButton"] + " >" + inputKeys["rButton"], scalePx(10), scalePx(60));
				ctxGame.fillText("[Up]: "        + inputState["uButton"] + " >" + inputKeys["uButton"], scalePx(10), scalePx(70));
				ctxGame.fillText("[Down]: "      + inputState["wButton"] + " >" + inputKeys["wButton"], scalePx(10), scalePx(80));
				ctxGame.fillText("[Upscale]: "   + inputState["zbugUp"] + " >" + inputKeys["zbugUp"], scalePx(10), scalePx(90));
				ctxGame.fillText("[Downscale]: " + inputState["z2bugDown"] + " >" + inputKeys["z2bugDown"], scalePx(10), scalePx(100));
				ctxGame.fillText("[Debug Switch]: " + inputState["z3bugExit"] + " >" + inputKeys["z3bugExit"], scalePx(10), scalePx(110));

				ctxGame.fillText("FPS: " + deltaFr, scalePx(20), scalePx(120));
			}
		}
		
		requestAnimationFrame(gameLoop);
	}



			/* Ideas:
			GAMEPLAY RUNDOWN:
			Objective: make (ORDER UP), destroy (skull), or empty (CLEANUP) out a kind of block from the pot (pre determined layouts?)

			The Pot: serves as the main vessel where the game takes place. 			
				>Everything in this pot will be subject to a heat tick, which depends on the kind of pot; some heat things up faster, some slower, some in major bursts, and some which never stop heating up.
				
				>Every block inside the pot either takes in or outputs energy from the pot. When some blocks take in enough energy, they will have a special "Sizzle" effect, which varies from block to block.


			Heat gauge:it sits next to the pot and serves as the Energy modifier for the pot. Starting at 1x effeciency, which describes the speed of the heat "ticks" the pot does every frame. 
				>Adding enough heat to the pot will fill the gauge, restting the bar and adding 1 to the multiplier.

				>As blocks expend and absorb heat, this meter will go up or down. Pots have a maximum amount of heat before they EXPLODE, and having a temperature of 0 puts the player in [[PERIL]] unless they heat back up FAST.


			Blocks: They can absorb heat and tey can break. They're stored on the one-dimensional belt, 

			The Belt: where all the player's blocks are stored. They can scroll left and right, or hold a button to strafe; changing blocks without the cursor moving positions. 
				>All the rules blocks have in the furnace/pot applies: heat, breaking, and movement. Adjacent tiles will absorb//expel heat depending on what's next to them!


			ENEMIES:
			SwapImp: If next to an item on the hot bar, it will swap with the middle block before the process occurs.
					 Once inside the hearth, they'll start to simmer. Once cooked, they spit out whatever is next to them
					 back to the hotbar. Alternatively, they get thrown out if you decide so.

			Junk: This block does nothing! However, it'll disappear once it finishes sizzling in whatever inventory it's in.

			DustBuni: Appears if the player has too many items in the hotbar. Will sizzle only when not viewed. If sizzled in 			  inventory, it turns the two adjacent items to DusBuni's. If a Dustbuni is Dusbuni'd, it turns into JUNK.
					  DustBuni's make for good fuel, but create SMOKE in the bellows when burned.


			Smoke: Will always move into the bellows if possible (when bellows are expanding). When sizzling, they trap heat; 		   completing a sizzle will not do anything by itself. However, when removed from a heat source, they will release that heat, slowly losing it over time. Once it has no more heat, it disappears.



			RESOURCES:
				PopKern: Inert when no heat. When it sizzles to completion, it breaks adjacent items and turns into Popcrn. Destroyed when sizzled to completion. Popcrn can also

				Coal: When sizzling, it greatly boosts the heat of the container it's in. Greatly. Exceedingly so. When sizzling, it is impossible to retrieve from the oven, easily causing overheating. Produces more Smoke than usual when heating.

				Ice: When sizzling, reduces heat in the container. Once cooked, it turns into water, which GREATLY impedes flame 	growth for as long as it sizzles. Critically so. Turns to steam in extreme heat.

				GluBall: when shot out and hits another block, it becomes a copy of it, with both splitting some of the heat/damage between them, and then instantly bounces in the direction it was fired from. If it hits the pot's border, it'll bounce back with a LOT of heat on it. Sizzle effect is turning into a junk block.

				PURE HEAT: extracts heat directly form the vessel into block form. Dissapears/breaks as soon as it cools down.




			INTERACTIONS:
				Multi-Blocks: blocks, when arranged together, Exodia and gain new properties/powers?
				
				Doodle Shapes: when arranging stable(?) blocks in a certain pattern, (same as above??)

			WaAYS OF PLAY:

			Farm Blocks: The player only has as many blocks as they have "captured" from the field. Other than that, they'd get a default block that's not all that powerful.

			Select Your Fighter: players can see the challenge beforehand and decide what blocks/pots they want to use to overcome it?

			*/

		</script>
	</body>
</html>

