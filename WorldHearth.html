<!DOCTYPE html>
<html>
	<head>
		<title>World Hearth</title>

		<meta charset="utf-8">
		<style>

			body {
				background-color: black;
			}

		</style>
	</head>

	<body onload="gameLoop()">
		<script>
//Start config options
			var pixelScale = 3;
			var bgColor = "#d7e894";
			var inputState = {
				aButton : [false, "done"],
				bButton : [false, "done"],
				lButton : [false, "done"],
				rButton : [false, "done"],
				uButton : [false, "done"],
				wButton : [false, "done"],
				zbugUp : [false, "done"],
				z2bugDown : [false, "done"],
				z3bugExit : [false, "done"]
			};
			var inputKeys = {
				aButton : "z", //Z by Default
				bButton : "x", //X by default
				lButton : "ArrowLeft", //Left Arrow Key
				rButton : "ArrowRight", //Right Arrow Key
				uButton : "ArrowUp", //Up Arrow Key
				wButton : "ArrowDown", //Down Arrow Key
				zbugUp : "9",
				z2bugDown : "0",
				z3bugExit : "`"
			};
			var trayImg = new Image();
			trayImg.src = "tray.png";
			var img = new Image();   // Create new img element	
			var traySize = 15;
			var blockSize = traySize;
			var globalInv = [];
			var localInv = [];
			var itemLog = [];
			var insertPoint = 0;
			var insertSpeed = 2;
			var hitBoxHold = {};
			var hitCheckHold = {};

//End config options

//DEBUG TOOLS
		var stop = false;
		var frameCount = 0;
		var now = performance.now();
		var debugMode = false;
		var deltaFr = 0;
		var deltaTime = performance.now();
		var frameBefore = 0;

		function carpenter(couch) {
			couch = globalInv[couch];

			if (inputState.rButton[1] == "held" && inputState.lButton[1] == "held") {
				//Blank on purpose
			}
			else if (inputState.rButton[1] == "held") {
				couch.xPos += 1;
			}
			else if (inputState.lButton[1] == "held") {
				couch.xPos -= 1;
			}


			if (inputState.wButton[1] == "held" && inputState.uButton[1] == "held") {
				//Blank on purpose
			}
			else if (inputState.wButton[1] == "held") {
				couch.yPos += 1;
			}
			else if (inputState.uButton[1] == "held") {
				couch.yPos -= 1;
			}
		}
//

//Start canvas delerations
			var canvas = document.createElement("canvas");
			canvas.id = "gameCanvas";
			canvas.width = 160 * pixelScale;
			canvas.height = 144 * pixelScale;
			canvas.style.position = "center";
			canvas.style.background = "white";
			canvas.style.position = "relative";
			canvas.style.left = (window.innerWidth/2 - canvas.width/2) +"px"; 
			canvas.style.top = (window.innerHeight/2 - canvas.height/2) + "px";

			var ctxGame = canvas.getContext("2d");
			ctxGame.imageSmoothingEnabled = false;

			ctxGame.font = (10 * pixelScale) + "px Arial";

			var body = document.getElementsByTagName("body")[0];
			body.appendChild(canvas);
//End canvas declarations

//Start Input Functions

			document.addEventListener("keydown", inputHandler, false);
			document.addEventListener("keyup", inputHandler, false);
			canvas.addEventListener("mousedown", rebindControls, false);
			//document.addEventListener("keypress", inputHandler, false);
			
			function inputHandler(event){
				for(var input in inputKeys){
					if (inputKeys[input] == event.key) {
						inputState[input][0] = event.type == 'keydown';
					}
					if (inputState[input] == "rebinding" && event.type == 'keyup') {
						inputKeys[input] = event.key;
						inputState[input] = [false, "done"];
						break;
					}
				}
				

				if (event.key == inputKeys["z3bugExit"] && event.type == 'keyup') {
					debugMode = !debugMode;
				}
			}

			function inputProcess(){
				for (var press in inputState) {
					if (inputState[press][0] && inputState[press][1] == "done") {
						inputState[press][1] = "tap";
					}
					else if (inputState[press][0] && inputState[press][1] == "tap") {
						inputState[press][1] = "held";
					}
					else if (!inputState[press][0]) {
						inputState[press][1] = "done";
					}
				}
			}

			function rebindControls() {
				debugMode = true;

				for (var remap in inputState) {
					inputState[remap] = "rebinding";
					inputKeys[remap] = "[?]";				
				}
			}

			function playerAction() {
				if (!debugMode) {
					if (inputState.lButton[1] == "tap" && insertPoint > 0) {
						insertPoint--;
					}

					if (inputState.rButton[1] == "tap" && insertPoint < Math.floor(globalInv[0].width / traySize) - 1) {
						insertPoint++;
					}

					if (inputState.uButton[1] == "tap") { //&& globalInv[0].capacity > globalInv[0].contents.length) {
						insertInventory(0, 0, true);
					}

					if (inputState.wButton[1] == "tap" && 0 < globalInv[0].contents.length) {
						for (var p = 0; p < globalInv[0].contents.length; p++) {
							if (globalInv[0].contents[globalInv[0].contents.length - p - 1][insertPoint] != 0) {

								globalInv[0].contents[globalInv[0].contents.length - p - 1][insertPoint] = 0;
								break;

							}
						}					
					}
				}
			}
//End Input Functions

//Sprite Cutting Functions
			var testImg = new Image();
			testImg.src = "pot.png";

			var junkImg = new Image();
			junkImg.src = "junk1.png";


//End Sprite Cutting Functions

//Items and inventory functions

		function Inventory(name, sprite, xPos, yPos, width, height, capacity, heat, anchor, anchorMod){
			this.name = name || "NO NAME";
			this.sprite = sprite || "NO IMAGE";
			this.capacity = capacity || 1;
			this.heat = heat || 1;
			this.xPos = xPos || 0;
			this.yPos = yPos || 0;
			this.xCrunch = 0;
			this.yCrunch = 0;
			this.width = width || 0;
			this.height = height || 0;
			this.anchorMod = anchorMod || [0,0];
			this.anchor = [anchor[0] + anchorMod[0], anchor[1] + anchorMod[1] - height / 2];
			this.contents = generateInv(this.height, this.width);
			//console.log("INVENTORY OBJECT LOADED");
		} 

		function generateInv (height, width) { 
			var pndInv = [];
			for (var rw = 0; rw < height / blockSize; rw++) {
				pndInv.push([]);

				for (var clm = 0; clm < width / blockSize; clm++) {	
					pndInv[rw].push(0);
				}	
			}

						//console.log("INVENTORY MATRIX READY");
			return pndInv;	
		}
		
		function Item(name, sprite, type, currCook, maxCook) {
			this.name = name || "???";
			this.type = type || "NULL";
			this.sprite = sprite || trayImg;
			this.currCook = currCook || 0;
			this.maxCook = maxCook || 0;
			this.xPos = 0;
			this.yPos = 0;
			this.xSpeed = 0;
			this.ySpeed = 0;
			this.InvEffect = 0;
			this.HrtEffect = 0;
			this.BllwEffect = 0;
			this.ThrEffect = 0;

			//console.log("ITEM OBJECT GOOD TO GO");
		}

		function drawItems() {
			for (var box in globalInv) {

				if (globalInv[box].contents.length <= 0) {
					break;
				}

				for (var i = 0; i < globalInv[box].contents.length; i++) {
					for (var v = 0; v < globalInv[box].contents[i].length; v++) {
						if (globalInv[box].contents[i][v] != 0) {
							scaleImg(
								globalInv[box].contents[i][v].sprite,
								globalInv[box].contents[i][v].xPos + globalInv[box].xPos,
								globalInv[box].contents[i][v].yPos	+ globalInv[box].yPos				
							);
						}
					}
				}
			}

			//console.log("DRAWING ITEMS!");
		}

		function itemPhysics() {
			hitBoxHold = -1;
			hitCheckHold = -1;

			for (var invs = 0; invs < globalInv.length; invs++) {	//Traverse all inventories
				for (var y = 0; y < globalInv[invs].contents.length; y++) {	//Traverse all blocks in a single inventory
					for (var x = 0; x < globalInv[invs].contents[y].length; x++) {	

						if (!debugMode) {
							ctxGame.strokeStyle ="#000000";
							ctxGame.fillStyle = "#000000";
							ctxGame.fillText("[" + (globalInv[invs].contents[y][x].xPos || "??") + ", " + (globalInv[invs].contents[y][x].yPos || "??") + "]", scalePx(x + x * 20 * 2), scalePx(10 + y * 8));
						}

						if (globalInv[invs].contents[y][x] != 0 && globalInv[invs].contents[y][x].ySpeed != 0) {

								if (globalInv[invs].contents[y][x].yPos <= globalInv[invs].anchor[1] ||
									(y - 1 >= 0 &&		
									globalInv[invs].contents[y][x].yPos <= globalInv[invs].contents[y - 1][x].yPos + blockSize &&
									globalInv[invs].contents[y][x] != globalInv[invs].contents[y][x])) 
								{
									globalInv[invs].contents[y][x].ySpeed = 0;
									console.log("BOP")
								}

								if (y - 1 >= 0) {
									while (globalInv[invs].contents[y][x].yPos <= globalInv[invs].contents[y - 1][x].yPos + blockSize &&
										   globalInv[invs].contents[y][x] == globalInv[invs].contents[y][x]
									) {

										globalInv[invs].contents[y][x].yPos += 1;
										console.log("Square NEW: " + globalInv[invs].contents[y][x].xPos + ", " + globalInv[invs].contents[y][x].yPos);
										console.log("Square OLD: " + globalInv[invs].contents[y - 1][x].xPos + ", " + globalInv[invs].contents[y - 1][x].yPos);

									}
								}
							}

							globalInv[invs].contents[y][x].yPos += globalInv[invs].contents[y][x].ySpeed;

						}

					}
				}
			}
					


		function drawInventories() {
			for (var inv in globalInv) {

				//scaleImg(globalInv[inv].sprite, globalInv[inv].xPos, globalInv[inv].yPos);
					//console.log("DRAWING INVENTORY SPRITE");
				scaleRect(
					globalInv[inv].anchor[0] + globalInv[inv].anchorMod[0] + globalInv[inv].xPos, //- (globalInv[inv].width / 2),
					globalInv[inv].anchor[1] + globalInv[inv].anchorMod[1] + globalInv[inv].yPos, //- (globalInv[inv].height / 2),
					globalInv[inv].width - globalInv[inv].xCrunch, 
					globalInv[inv].height - globalInv[inv].yCrunch
				);

					//console.log("DRAWING RECTANGLE");
			}
			scaleRect(
				globalInv[inv].anchor[0] + globalInv[inv].anchorMod[0] + globalInv[inv].xPos + insertPoint * traySize, 
				globalInv[inv].yPos + globalInv[inv].sprite.height + 2, 
				traySize, 
				traySize
			);
		}

		function insertInventory(itemIdx, targInv, isVert){			
			var newBlock = Object.assign({}, itemLog[itemIdx]);
			targInv = globalInv[targInv];
			isVert = isVert || false;

			newBlock.xPos = targInv.anchor[0] + (traySize * insertPoint);
			newBlock.yPos = targInv.sprite.height;

			if (isVert) {
				newBlock.xSpeed = 0;
				newBlock.ySpeed = -insertSpeed;				
			}
			else {				
				newBlock.xSpeed = insertSpeed;
				newBlock.ySpeed = 0;
			}

			for (var ins = 0; ins < targInv.contents.length; ins++) {
				if (targInv.contents[ins][insertPoint] == 0) {
					targInv.contents[ins][insertPoint] = newBlock;
					break;
				}
			}	
			//console.log("ADDING TO INVENTORY");		
		}



//End item/inventory objects/functions

//Screen Functions
		function scalePx(dim){
			return (pixelScale * dim);
		}

		function scaleImg(spr, sprX, sprY){
			ctxGame.drawImage(spr, scalePx(sprX), scalePx(sprY), scalePx(spr.width), scalePx(spr.height));
		}

		function scaleRect(rectX, rectY, recWid, recHgt) {
			ctxGame.strokeRect(scalePx(rectX), scalePx(rectY), scalePx(recWid), scalePx(recHgt));

			//console.log("RECTANGLE DRAWN: With FILL: " + ctxGame.fillStyle + " and STROKE: " + ctxGame.strokeStyle);
		}


		function clearScreen(){
			ctxGame.fillStyle = bgColor;
			ctxGame.fillRect(0, 0, canvas.width, canvas.height);

			canvas.style.left = (window.innerWidth/2 - canvas.width/2) +"px"; 
			canvas.style.top = (window.innerHeight/2 - canvas.height/2) + "px";
			ctxGame.strokeStyle ="#000000";
			ctxGame.fillStyle = "#000000";
			ctxGame.imageSmoothingEnabled = false; 

			/* ctxGame.beginPath();
				ctxGame.moveTo(canvas.width / 2, 0);
				ctxGame.lineTo(canvas.width /2, canvas.height);
				ctxGame.stroke(); */


		}

		function changeScale(){
			var modifier = 0;

			if (inputState["zbugUp"][1] == "tap"){
				modifier = 1;
			}
			if (inputState["z2bugDown"][1] == "tap") {
				modifier = -1;
			}

			pixelScale += modifier;

			if (pixelScale <= 0) {
				pixelScale = 1;
			}

			canvas.width = 160 * pixelScale;
			canvas.height = 144 * pixelScale;
			ctxGame.font = (10 * pixelScale) + "px Arial"; 
		}
//End screen functions


//Last minute initializations
	//			  function Inventory(  name,  sprite, xPos, yPos, width,       height,       capacity, heat, anchor, anchorMod){
		globalInv.push(new Inventory("Hearth", testImg, 48, 60, blockSize * 3, blockSize * 6,    8,     10,  [9, 19], [0, -2]));

		itemLog.push(new Item("Junk", junkImg, "bad", "0", "50"));

		//for (j = 0; j < 3; j++) {
			//globalInv[0].contents.push(itemLog[0]); 
		//}

		//insertInventory(0, 0, true);

//End of last calls

//console.log("DING DING");

	function gameLoop(){
		now = performance.now();

		if (now - deltaTime > 1000) {
			deltaFr = frameCount - frameBefore;
			frameBefore = frameCount;
			deltaTime = now;
		}



		if (!stop) {
			frameCount++;

			changeScale();
			clearScreen();
			inputProcess();
			playerAction();


			itemPhysics();
			drawInventories();
			drawItems();

			if (debugMode) {
			
			carpenter(0);

			//ctxGame.strokeStyle ="#000000";
			//ctxGame.fillStyle = "#000000";

			//ctxGame.fillText("X: " + globalInv[0].xPos + " Y: " + globalInv[0].yPos, 
			//					scalePx(globalInv[0].xPos), 
			//					scalePx(globalInv[0].yPos)
			//				);

			ctxGame.fillText("[A]: "         + inputState["aButton"] + " >" + inputKeys["aButton"], scalePx(10), scalePx(30));
			ctxGame.fillText("[B]: "         + inputState["bButton"] + " >" + inputKeys["bButton"], scalePx(10), scalePx(40));
			ctxGame.fillText("[Left]: "      + inputState["lButton"] + " >" + inputKeys["lButton"], scalePx(10), scalePx(50));
			ctxGame.fillText("[Right]: "     + inputState["rButton"] + " >" + inputKeys["rButton"], scalePx(10), scalePx(60));
			ctxGame.fillText("[Up]: "        + inputState["uButton"] + " >" + inputKeys["uButton"], scalePx(10), scalePx(70));
			ctxGame.fillText("[Down]: "      + inputState["wButton"] + " >" + inputKeys["wButton"], scalePx(10), scalePx(80));
			ctxGame.fillText("[Upscale]: "   + inputState["zbugUp"] + " >" + inputKeys["zbugUp"], scalePx(10), scalePx(90));
			ctxGame.fillText("[Downscale]: " + inputState["z2bugDown"] + " >" + inputKeys["z2bugDown"], scalePx(10), scalePx(100));
			ctxGame.fillText("[Debug Switch]: " + inputState["z3bugExit"] + " >" + inputKeys["z3bugExit"], scalePx(10), scalePx(110));

			ctxGame.fillText("FPS: " + deltaFr, scalePx(20), scalePx(120));
			}
		}
		
		requestAnimationFrame(gameLoop);
	}



			/* Ideas:
			ENEMIES:
			SwapImp: If next to an item on the hot bar, it will swap with the middle block before the process occurs.
					 Once inside the hearth, they'll start to simmer. Once cooked, they spit out whatever is next to them
					 back to the hotbar. Alternatively, they get thrown out if you decide so.

			Junk: This block does nothing! However, it'll disappear once it finishes sizzling in whatever inventory it's in.

			DustBuni: Appears if the player has too many items in the hotbar. Will sizzle only when not viewed. If sizzled in 			  inventory, it turns the two adjacent items to DusBuni's. If a Dustbuni is Dusbuni'd, it turns into JUNK.
					  DustBuni's make for good fuel, but create SMOKE in the bellows when burned.


			Smoke: Will always move into the bellows if possible (when bellows are expanding). When sizzling, they trap heat; 		   completing a sizzle will not do anything by itself. However, when removed from a heat source, they will release that heat, slowly losing it over time. Once it has no more heat, it disappears.



			RESOURCES:
				PopKern: Inert when no heat. When it sizzles to completion, it breaks adjacent items and turns into Popcrn. Destroyed when sizzled to completion. Popcrn can also

				Coal: When sizzling, it greatly boosts the heat of the container it's in. Greatly. Exceedingly so. When sizzling, it is impossible to retrieve from the oven, easily causing overheating. Produces more Smoke than usual when heating.

				Ice: When sizzling, reduces heat in the container. Once cooked, it turns into water, which GREATLY impedes flame 	growth for as long as it sizzles. Critically so. Turns to steam in extreme heat.




			INTERACTIONS:



			*/

		</script>
	</body>
</html>

