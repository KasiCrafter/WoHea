<!DOCTYPE html>
<html>
	<head>
		<title>World Hearth</title>

		<meta charset="utf-8">
		<style>

			body {
				background-color: black;
			}

		</style>
	</head>

	<body onload="gameLoop()">
		<script>
//Start config options
		var pixelScale = 3;
		var bgColor = "#d7e894";
		var inputState = {
			aButton : [false, "done"],
			bButton : [false, "done"],
			lButton : [false, "done"],
			rButton : [false, "done"],
			uButton : [false, "done"],
			wButton : [false, "done"],
			zbugUp : [false, "done"],
			z2bugDown : [false, "done"],
			z3bugExit : [false, "done"],
			z4bugSpecial : [false, "done"]
		};
		var inputKeys = {
			aButton : "z", //Z by Default
			bButton : "x", //X by default
			lButton : "ArrowLeft", //Left Arrow Key
			rButton : "ArrowRight", //Right Arrow Key
			uButton : "ArrowUp", //Up Arrow Key
			wButton : "ArrowDown", //Down Arrow Key				
			zbugUp : "9",
			z2bugDown : "0",
			z3bugExit : "`",
			z4bugSpecial : "Control"
		};
		var trayImg = new Image();
		trayImg.src = "tray.png";
		var img = new Image();   // Create new img element	
		var blockSize = 16;
		var blockPadding = 2;
		var traySize = blockSize;			
		var globalInv = [];
		var localInv = [];
		var itemLog = [];
		var insertPoint = 0;
		var insertSpeed = 2;
		var hitBoxHold = {};
		var hitCheckHold = {};



		var debugInc = 0


//End config options

//DEBUG TOOLS
		var stop = false;
		var frameCount = 0;
		var now = performance.now();
		var debugMode = false;
		var rebindMode = false;
		var deltaFr = 0;
		var deltaTime = performance.now();
		var frameBefore = 0;



		function carpenter(couch) {
			couch = globalInv[couch];

			if (inputState.rButton[1] == "held" && inputState.lButton[1] == "held") {
				//Blank on purpose
			}
			else if (inputState.rButton[1] == "held") {
				couch.xPos += 1;
			}
			else if (inputState.lButton[1] == "held") {
				couch.xPos -= 1;
			}


			if (inputState.wButton[1] == "held" && inputState.uButton[1] == "held") {
				//Blank on purpose
			}
			else if (inputState.wButton[1] == "held") {
				couch.yPos += 1;
			}
			else if (inputState.uButton[1] == "held") {
				couch.yPos -= 1;
			}
		}


		function ledger(currInv, a, b){
			//if (debugMode && inputState.bButton[1] != "held") { //Print contents of inventory in debug mode
				var debugFontSize = (canvas.width / globalInv[currInv].horzCap) / (5 * pixelScale);//16;

				ctxGame.save();			

				ctxGame.font = scalePx(debugFontSize) + "px Monospace";

				ctxGame.fillText("[" + (globalInv[currInv].contents[a][b].xPos || "??") + "," + (globalInv[currInv].contents[a][b].yPos || "??") + "]", scalePx((b * 3 * debugFontSize) + (10 * b)), scalePx(debugFontSize + a * debugFontSize));//scalePx(v + v * 20), scalePx(10 + i * 8));

				ctxGame.restore();
			//}			
		}
//

//Start canvas delerations
		var canvas = document.createElement("canvas");
		canvas.id = "gameCanvas";
		canvas.width = 160 * pixelScale;
		canvas.height = 144 * pixelScale;
		canvas.style.position = "center";
		canvas.style.background = "white";
		canvas.style.position = "relative";
		canvas.style.left = (window.innerWidth/2 - canvas.width/2) +"px"; 
		canvas.style.top = (window.innerHeight/2 - canvas.height/2) + "px";		
		

		var ctxGame = canvas.getContext("2d");
		ctxGame.imageSmoothingEnabled = false;

		ctxGame.font = (10 * pixelScale) + "px Arial";
		//ctxGame.lineCap = "square";

		var body = document.getElementsByTagName("body")[0];
		body.appendChild(canvas);
//End canvas declarations

//Start Input Functions

		document.addEventListener("keydown", inputHandler, false);
		document.addEventListener("keyup", inputHandler, false);
		canvas.addEventListener("mousedown", rebindControls, false);
		
		function inputHandler(event){
			for(var input in inputKeys){
				if (inputKeys[input] == event.key) {
					inputState[input][0] = event.type == 'keydown';
					rebindMode = false;
				}
				if (inputState[input] == "rebinding" && event.type == 'keyup') {
					inputKeys[input] = event.key;
					inputState[input] = [false, "done"];
					break;
				}				
			}			

			if (event.key == inputKeys["z3bugExit"] && event.type == 'keyup') {
				debugMode = !debugMode;
			}
		}

		function inputProcess(){
			for (var press in inputState) {
				if (inputState[press][0] && inputState[press][1] == "done") {
					inputState[press][1] = "tap";
				}
				else if (inputState[press][0] && inputState[press][1] == "tap") {
					inputState[press][1] = "held";
				}
				else if (!inputState[press][0]) {
					inputState[press][1] = "done";
				}
			}
		}

		function rebindControls() {
			rebindMode = true;

			for (var remap in inputState) {
				inputState[remap] = "rebinding";
				inputKeys[remap] = "[?]";				
			}

		}

		function playerAction() {
			if (!debugMode || inputState.z4bugSpecial[1] == "held") {
				if (inputState.lButton[1] == "tap" && insertPoint > 0) {
					insertPoint--;
				}

				if (inputState.rButton[1] == "tap" && insertPoint < Math.floor(globalInv[0].width / traySize) - 1) {
					insertPoint++;
				}

				if (inputState.aButton[1] == "tap") {
					if (debugInc + 1 <= itemLog.length - 1) {
						debugInc++;
					}
					else if (debugInc + 1 > itemLog.length - 1)
						debugInc = 0;

					globalInv[0].temperature++;
				}				

				if (inputState.uButton[1] == "tap") { 
					insertInventory(debugInc, 0, true);
					console.log(debugInc);
				}

				if (inputState.wButton[1] == "tap" && 0 < globalInv[0].contents.length) {
					for (var p = 0; p < globalInv[0].contents.length; p++) {
						if (globalInv[0].contents[globalInv[0].contents.length - p - 1][insertPoint] != 0) {

							globalInv[0].contents[globalInv[0].contents.length - p - 1][insertPoint] = 0;
							break;

						}
					}					
				}
			}
		}
//End Input Functions

//Sprite Cutting Functions

		//constructor for sprite sheets
		function SpriteSheet(path, tileWidth, tileHeight){
			var self = this;
			this.tileWidth = tileWidth;
			this.tileHeight = tileHeight;

			this.image = new Image();
			this.image.src = path;			
			this.image.onload = function() {
				self.tilesPerRow = Math.floor(self.image.width / self.tileWidth);
			};

			//Each block will have a coordinate value so we can via BlockName.index instead of just numbers. Readibility!
			this.drawSprite = function(cellIdx, xPos, yPos) { 
				//console.log(this.tileHeight * cellIdx[1]);
				scaleImg(this.image, xPos, yPos, this.tileWidth, this.tileHeight, cellIdx[1] * this.tileWidth, cellIdx[0] * this.tileHeight);

			};


		}

		



		var testImg = new Image();
		testImg.src = "pot.png";

		var junkImg = new Image();
		junkImg.src = "junk2.png";

		var junk2Img = new Image();
		junk2Img.src = "junk1.png"

		var bunnImg = new Image();
		bunnImg.src = "dustbunny.png";

		var cornImg = new Image();
		cornImg.src = "popcorn.png";

		var imp1Img = new Image();
		imp1Img.src = "imp1.png";
//End Sprite Cutting Functions

//Items and inventory functions
	//Inventory Functions
		function Inventory(name, sprite, xPos, yPos, horzCap, vertCap, maxHeat, temperature, tickRate, anchor, anchorMod){
			this.name = name || "NO NAME";
			this.sprite = sprite || "NO IMAGE";
			//this.heatFactor = (heatFactor * 1.0) || 1;
			this.maxHeat = (maxHeat * 1.0) || 100;
			this.temperature = (temperature * 1.0) || 0;
			this.tickRate = tickRate || 1;
			this.orgTickRate = tickRate;
			this.xPos = xPos || 0;
			this.yPos = yPos || 0;
			this.xCrunch = 0;
			this.yCrunch = 0;
			this.horzCap = (horzCap % (Math.floor(canvas.width / ((blockSize + blockPadding) * pixelScale)) - 1))|| 1;
			this.vertCap = (vertCap % (Math.floor(canvas.height / ((blockSize + blockPadding) * pixelScale)) - 1))|| 1;
			this.height =  this.vertCap * (blockSize + blockPadding) + blockPadding;
			this.width = this.horzCap * (blockSize + blockPadding) + blockPadding;
			this.anchorMod = anchorMod || [0,0];
			this.anchor = [anchor[0] + anchorMod[0], anchor[1] + anchorMod[1] - this.height / 2];
			this.contents = generateInv(this.horzCap, this.vertCap);
			this.timeCooking = 0;
		} 


		function generateInv (xUnits, yUnits) { 
			var pndInv = [];
			for (var rw = 0; rw < yUnits; rw++) {
				pndInv.push([]);

				for (var clm = 0; clm < xUnits; clm++) {	
					pndInv[rw].push(0);
				}	
			}
			return pndInv;	
		}


		function drawInventories() {
			for (var inv in globalInv) {

				//scaleImg(globalInv[inv].sprite, globalInv[inv].xPos, globalInv[inv].yPos);
					//console.log("DRAWING INVENTORY SPRITE");
				scaleRect(
					globalInv[inv].anchor[0] + globalInv[inv].xPos,
					globalInv[inv].anchor[1] + globalInv[inv].yPos,
					globalInv[inv].width - globalInv[inv].xCrunch, 
					globalInv[inv].height - globalInv[inv].yCrunch
				);

			}
			//Draw block selection cursor
			scaleRect(
				globalInv[inv].anchor[0] + globalInv[inv].xPos + insertPoint * (blockSize + blockPadding) + blockPadding, 
				globalInv[inv].anchor[1] + globalInv[inv].yPos + globalInv[inv].height + 5, 
				blockSize, 
				blockSize
			);
		}


		function drawHeat(inv) {
			var meterHeight = inv.height * (inv.temperature / inv.maxHeat);
			var barY = inv.yPos + inv.anchor[1];
			var barX = inv.xPos - inv.anchor[0] - blockSize / 2;
			var barWidth = (blockSize / 4) + (inv.maxHeat / inv.height) * 1; //blockSize / 4	;

			//scaleText(multiplier + "x", barX - blockSize, barY + inv.height)
			//scaleText(barY + inv.height - meterHeight, barX - blockSize, barY + inv.height);
			//scaleText(inv.height - meterHeight, barX - blockSize, barY + inv.height + blockSize / 2);
			//scaleText(meterHeight - ctxGame.lineWidth, barX - blockSize, barY + inv.height + blockSize);

			scaleRect(
				barX, 
				barY, 
				barWidth, 
				inv.height
			);

			scaleRect(
				barX, 
				barY + inv.height - meterHeight, 
				barWidth, 
				meterHeight,
				true
			);

		}


		function insertInventory(itemIdx, targInv, isVert){			
			var newBlock = Object.create(itemLog[itemIdx])
			targInv = globalInv[targInv];
			isVert = isVert || false;

			newBlock.xPos = targInv.anchor[0] + blockPadding + (blockPadding + blockSize) * insertPoint;
			newBlock.yPos = targInv.yPos - targInv.anchor[1];

			if (isVert) {
				newBlock.xSpeed = 0;
				newBlock.ySpeed = -insertSpeed;				
			}
			else {				
				newBlock.xSpeed = insertSpeed;
				newBlock.ySpeed = 0;
			}

			for (var ins = 0; ins < targInv.contents.length; ins++) {
				if (targInv.contents[ins][insertPoint] == 0) {
					targInv.contents[ins][insertPoint] = newBlock;
					break;
				}
			}		
		}
	//Item functions
		function Item(name, sprite, type, currCook, maxCook, heatEffect) {
			this.name = name || "???";
			this.type = type || "NULL";
			this.sprite = sprite || trayImg;
			this.currCook = currCook || 0;
			this.maxCook = maxCook || 0;
			this.xPos = 0;
			this.yPos = 0;
			this.xSpeed = 0;
			this.ySpeed = 0;
			this.invEffect = 0;
			this.heatEffect = heatEffect || function(){return;};
			this.breakEffect = 0;
			this.bumpEffect = 0;
		}


		function drawItems() {
			for (var box in globalInv) {

				if (globalInv[box].contents.length <= 0) {
					break;
				}

				for (var i = 0; i < globalInv[box].contents.length; i++) {
					for (var v = 0; v < globalInv[box].contents[i].length; v++) {
						if (globalInv[box].contents[i][v] != 0) {
							/*scaleImg(
								globalInv[box].contents[i][v].sprite,
								globalInv[box].contents[i][v].xPos + globalInv[box].xPos,
								globalInv[box].contents[i][v].yPos	+ globalInv[box].yPos				
							);*/
							blockSheet.drawSprite(
								globalInv[box].contents[i][v].sprite,
								globalInv[box].contents[i][v].xPos + globalInv[box].xPos,
								globalInv[box].contents[i][v].yPos	+ globalInv[box].yPos
							);
						}


						

						if (debugMode && inputState.bButton[1] != "held") { //Print contents of inventory in debug mode
							ledger(box, i, v);
							/*ctxGame.strokeStyle ="#000000";
							ctxGame.fillStyle = "#000000";
							var fontSize = (canvas.width / globalInv[box].horzCap) / 16;
							ctxGame.font = scalePx(fontSize) + "px Monospace";
							ctxGame.fillText("[" + (globalInv[box].contents[i][v].xPos || "??") + "," + (globalInv[box].contents[i][v].yPos || "??") + "]", scalePx((v * 3 * fontSize) + (10 * v)), scalePx(fontSize + i * fontSize));//scalePx(v + v * 20), scalePx(10 + i * 8));*/
						}
					}
				}
			}
		}


		function itemPhysics() {
			hitBoxHold = -1;
			hitCheckHold = -1;

			for (var invs = 0; invs < globalInv.length; invs++) {	//Traverse all inventories
				for (var y = 0; y < globalInv[invs].contents.length; y++) {	//Traverse all blocks in a single inventory
					for (var x = 0; x < globalInv[invs].contents[y].length; x++) {	

						if (debugMode && inputState.bButton[1] == "held") { //Print contents of inventory in debug mode
							ledger(invs, y, x);
						/*	ctxGame.strokeStyle ="#000000";
							ctxGame.fillStyle = "#000000";
							ctxGame.fillText("[" + (globalInv[invs].contents[y][x].xPos || "??") + ", " + (globalInv[invs].contents[y][x].yPos || "??") + "]", scalePx(x + x * 20 * 2), scalePx(10 + y * 8)); */
						}

						//Check if object is a valid block and that it is moving
						if (globalInv[invs].contents[y][x] != 0 && globalInv[invs].contents[y][x].ySpeed != 0) {

							//If the block touches the top of the inventory (y-coordinate) OR another block, set block speed to 0
							if (globalInv[invs].contents[y][x].yPos <= globalInv[invs].anchor[1] + blockPadding ||
								(y - 1 >= 0 &&		
								globalInv[invs].contents[y][x].yPos <= globalInv[invs].contents[y - 1][x].yPos + blockSize + blockPadding &&
								globalInv[invs].contents[y][x] != globalInv[invs].contents[y][x])) 
							{
								globalInv[invs].contents[y][x].ySpeed = 0;
								//globalInv[invs].contents[y][x].yPos -= 1;
								console.log("BOP")
							}

							//If contact is made another block, move block one pixel away until the collission is resolved
							if (y - 1 >= 0) {
								while (globalInv[invs].contents[y][x].yPos <= 
									   globalInv[invs].contents[y - 1][x].yPos + blockSize + blockPadding + 1
									   &&
									   globalInv[invs].contents[y][x] == globalInv[invs].contents[y][x]) 
								{								

									globalInv[invs].contents[y][x].yPos += 1;

								}
							}
						}
							//If something's moving, move it to the correct distance according to its speed
							globalInv[invs].contents[y][x].yPos += globalInv[invs].contents[y][x].ySpeed;

					}

				}
			}
		}					
//End item/inventory objects/functions

//Screen Functions
		function scalePx(dim){
			return (pixelScale * dim);
		}

		function scaleImg(spr, sprX, sprY, clipWidth, clipHeight, clipX, clipY){
			if (arguments.length == 3) {
				ctxGame.drawImage(spr, scalePx(sprX), scalePx(sprY), scalePx(spr.width), scalePx(spr.height));
			}
			else if (arguments.length == 7) {
				ctxGame.drawImage(
					spr,
					clipX,
					clipY,
					clipWidth,
					clipHeight,
					scalePx(sprX),
					scalePx(sprY),
					scalePx(clipWidth),
					scalePx(clipHeight)
				);

				//console.log(clipX);
			}
			else {
				console.log("UNEXPECTED # of arguments in scaleImg().");
			}
		}

		function scaleRect(rectX, rectY, rectWid, rectHgt, doFill) {
			//scaleText(rectHgt, rectX + blockSize, rectY + blockSize / 2)
			if (rectWid - ctxGame.lineWidth <= rectWid){  
				rectWid += ctxGame.lineWidth;
			}
			else {
				rectWid -= ctxGame.lineWidth;
			}

			if (rectHgt - ctxGame.lineWidth <= rectHgt){  
				rectHgt += ctxGame.lineWidth;
			}
			else {
				rectHgt -= ctxGame.lineWidth;
			}

			
			rectY -= 0.5;
			rectX -= 0.5;


			if (doFill) {
				ctxGame.fillRect(scalePx(rectX), scalePx(rectY), scalePx(rectWid), scalePx(rectHgt));
			}
			else {
				ctxGame.strokeRect(scalePx(rectX), scalePx(rectY), scalePx(rectWid), scalePx(rectHgt) );
			}
		}

		function scaleText(text, posX, posY) {
			ctxGame.fillText(text, scalePx(posX), scalePx(posY));
		}


		function clearScreen(){
			ctxGame.fillStyle = bgColor;
			ctxGame.fillRect(0, 0, canvas.width, canvas.height);
			ctxGame.font = (10 * pixelScale) + "px Arial";

			canvas.style.left = (window.innerWidth/2 - canvas.width/2) +"px"; 
			canvas.style.top = (window.innerHeight/2 - canvas.height/2) + "px";
			ctxGame.strokeStyle ="#000000";
			ctxGame.fillStyle = "#000000";
			ctxGame.imageSmoothingEnabled = false; 

		}

		function changeScale(){
			var modifier = 0;

			if (inputState["zbugUp"][1] == "tap"){
				modifier = 1;
			}
			if (inputState["z2bugDown"][1] == "tap") {
				modifier = -1;
			}

			pixelScale += modifier;

			if (pixelScale <= 0) {
				pixelScale = 1;
			}

			canvas.width = 160 * pixelScale;
			canvas.height = 144 * pixelScale;
			ctxGame.font = (10 * pixelScale) + "px Arial"; 
		}
//End screen functions

//Gameplay Mechanic Methods


	function timerCheck(startTime, duration) {
		var timerDelta = deltaTime - startTime;

		if (timerDelta >= duration) {
			return true;
		}

		return false;
	}


	function tickPot() {
		for (stuff in globalInv) {
			var inv = globalInv[stuff]

			if (inv.timeCooking == 0) {
				inv.timeCooking = now;
				return false
			}

			if (!timerCheck(inv.timeCooking, inv.tickRate)){
				//console.log("SKIP");
				continue;
			}

			inv.timeCooking = now;	

			if (inv.temperature < inv.maxHeat) {
				inv.temperature++;
			}
			else if (inv.temperature > inv.maxHeat) {
				inv.temperature = inv.maxHeat;
			}

			//var multiplier = calcMultiplier(inv)[0];
								

			for (var row in inv.contents) {
				for (var col in inv.contents[row]){
					if (inv.contents[row][col] != 0) {
						inv.contents[row][col].currCook += inv.tickRate;

						if (inv.contents[row][col].currCook >= inv.contents[row][col].maxCook) {
							inv.contents[row][col].heatEffect(self);
							inv.contents[row][col].currCook = 0;
							//console.log("SPICY MOVE! !");
						}

					}
				}
			}
			
		}
	}
//End of game mechanic methods

//Last minute initializations
	/*		  
	function Inventory(
		name,  
		sprite, 
		xPos, 
		yPos, 
		horzCap,       
		vertCap,       
		heatFactor, [max heat]
		temperature, 
		tickRate,
		anchor, 
		anchorMod
	)*/
	globalInv.push(
		new Inventory(
			"Hearth", 
			testImg, 
			48, 
			40, 
			6, 
			2,    
			200,          
			0,         
			1,   
			[9, 19], 
			[-1, -4]
		)
	);

	//      Item(name, 		sprite, 	type, currCook, maxCook)
	/*itemLog = [
		new Item("Junk",    junkImg, 	"bad",	 0, 	  5,
		//Heat function
			function() {
				if (this.sprite == junkImg) {
					this.sprite = junk2Img;
					console.log("exit org");
				}
				else if (this.sprite == junk2Img) {
					this.sprite = junkImg;
					console.log("exit mod");
				}
				console.log(typeof(this.sprite));
			}
		),
		new Item("Imp",     imp1Img, 	"bad", 	0, 		6.6),
		new Item("Dstbuni",	bunnImg, 	"bad", 	0, 		5),
		new Item("Popcrn", 	cornImg, 	"meh", 	0, 		20)
	];*/

	itemLog = [
		new Item("Imp",     [0,1], 	"bad", 	0, 		6.6),
		new Item("Junk",    [1,0], 	"bad",	0, 	  	5,)	,
		new Item("Dstbuni",	[1,1], 	"bad", 	0, 		5)	,
		new Item("Popcrn", 	[1,2], 	"meh", 	0, 		20)

	];

	blockSheet = new SpriteSheet("blocksheet.png", 16, 16);

//End of last calls


	function gameLoop(){
		now = performance.now();

		if (now - deltaTime > 1000) {
			deltaFr = frameCount - frameBefore;
			frameBefore = frameCount;
			deltaTime = now;
		}



		if (!stop) {
			frameCount++;

			changeScale();
			clearScreen();
			inputProcess();
			playerAction();

			blockSheet.drawSprite([2,1], 20, 20);

			tickPot();
			itemPhysics();
			drawInventories();
			drawItems();
			drawHeat(globalInv[0]);

			if (debugMode) {

				if (inputState.z4bugSpecial[1] != "held"){
					carpenter(0);
				}

				ctxGame.fillText("X: " + globalInv[0].xPos + "(" + globalInv[0].anchor[0] + ")" 
								+ " Y: " + globalInv[0].yPos + "(" + globalInv[0].anchor[1] + ")", 
									canvas.width / 2,//scalePx(globalInv[0].xPos), 
									canvas.height / 2 //scalePx(globalInv[0].yPos)
								);

				ctxGame.fillText("FPS: " + deltaFr, scalePx(20), scalePx(120));
			}

			if (rebindMode) {
				ctxGame.fillText("[A]: "         + inputState["aButton"] + " >" + inputKeys["aButton"], scalePx(10), scalePx(30));
				ctxGame.fillText("[B]: "         + inputState["bButton"] + " >" + inputKeys["bButton"], scalePx(10), scalePx(40));
				ctxGame.fillText("[Left]: "      + inputState["lButton"] + " >" + inputKeys["lButton"], scalePx(10), scalePx(50));
				ctxGame.fillText("[Right]: "     + inputState["rButton"] + " >" + inputKeys["rButton"], scalePx(10), scalePx(60));
				ctxGame.fillText("[Up]: "        + inputState["uButton"] + " >" + inputKeys["uButton"], scalePx(10), scalePx(70));
				ctxGame.fillText("[Down]: "      + inputState["wButton"] + " >" + inputKeys["wButton"], scalePx(10), scalePx(80));
				ctxGame.fillText("[Upscale]: "   + inputState["zbugUp"] + " >" + inputKeys["zbugUp"], scalePx(10), scalePx(90));
				ctxGame.fillText("[Downscale]: " + inputState["z2bugDown"] + " >" + inputKeys["z2bugDown"], scalePx(10), scalePx(100));
				ctxGame.fillText("[Debug Switch]: " + inputState["z3bugExit"] + " >" + inputKeys["z3bugExit"], scalePx(10), scalePx(110));
				
			}
		}
		
		requestAnimationFrame(gameLoop);
	}



			/* Ideas:
			-max tick rate = meterheight / heatFactor
			-low heat factor = low max tick rate, low ambient tick rate
			-max temperature = based on the container, it will have a ratio between heat given TO blocks and heat GAINED by blocks. go too far one way or another and container dies(?)








			GAMEPLAY RUNDOWN:
			Objective: make (ORDER UP), destroy (skull), or empty (CLEANUP) out a kind of block from the pot (pre determined layouts?)

			The Pot: serves as the main vessel where the game takes place. 			
				>Everything in this pot will be subject to a heat tick, which depends on the kind of pot; some heat things up faster, some slower, some in major bursts, and some which never stop heating up.
				
				>Every block inside the pot either takes in or outputs energy from the pot. When some blocks take in enough energy, they will have a special "Sizzle" effect, which varies from block to block.


			Heat gauge:it sits next to the pot and serves as the Energy modifier for the pot. Starting at 1x effeciency, which describes the speed of the heat "ticks" the pot does every frame. 
				>Adding enough heat to the pot will fill the gauge, restting the bar and adding 1 to the multiplier.

				>As blocks expend and absorb heat, this meter will go up or down. Pots have a maximum amount of heat before they EXPLODE, and having a temperature of 0 puts the player in [[PERIL]] unless they heat back up FAST.


			Blocks: They can absorb heat and tey can break. They're stored on the one-dimensional belt, 

			The Belt: where all the player's blocks are stored. They can scroll left and right, or hold a button to strafe; changing blocks without the cursor moving positions. 
				>All the rules blocks have in the furnace/pot applies: heat, breaking, and movement. Adjacent tiles will absorb//expel heat depending on what's next to them!


			ENEMIES:
			SwapImp: If next to an item on the hot bar, it will swap with the middle block before the process occurs.
					 Once inside the hearth, they'll start to simmer. Once cooked, they spit out whatever is next to them
					 back to the hotbar. Alternatively, they get thrown out if you decide so.

			Junk: This block does nothing! However, it'll disappear once it finishes sizzling in whatever inventory it's in.

			DustBuni: Appears if the player has too many items in the hotbar. Will sizzle only when not viewed. If sizzled in 			  inventory, it turns the two adjacent items to DusBuni's. If a Dustbuni is Dusbuni'd, it turns into JUNK.
					  DustBuni's make for good fuel, but create SMOKE in the bellows when burned.


			Smoke: Will always move into the bellows if possible (when bellows are expanding). When sizzling, they trap heat; 		   completing a sizzle will not do anything by itself. However, when removed from a heat source, they will release that heat, slowly losing it over time. Once it has no more heat, it disappears.



			RESOURCES:
				PopKern: Inert when no heat. When it sizzles to completion, it breaks adjacent items and turns into Popcrn. Destroyed when sizzled to completion. Popcrn can also

				Coal: When sizzling, it greatly boosts the heat of the container it's in. Greatly. Exceedingly so. When sizzling, it is impossible to retrieve from the oven, easily causing overheating. Produces more Smoke than usual when heating.

				Ice: When sizzling, reduces heat in the container. Once cooked, it turns into water, which GREATLY impedes flame 	growth for as long as it sizzles. Critically so. Turns to steam in extreme heat.

				GluBall: when shot out and hits another block, it becomes a copy of it, with both splitting some of the heat/damage between them, and then instantly bounces in the direction it was fired from. If it hits the pot's border, it'll bounce back with a LOT of heat on it. Sizzle effect is turning into a junk block.

				PURE HEAT: extracts heat directly form the vessel into block form. Dissapears/breaks as soon as it cools down.




			INTERACTIONS:
				Multi-Blocks: blocks, when arranged together, Exodia and gain new properties/powers?
				
				Doodle Shapes: when arranging stable(?) blocks in a certain pattern, (same as above??)

			WaAYS OF PLAY:

			Farm Blocks: The player only has as many blocks as they have "captured" from the field. Other than that, they'd get a default block that's not all that powerful.

			Select Your Fighter: players can see the challenge beforehand and decide what blocks/pots they want to use to overcome it?

			*/

		</script>
	</body>
</html>

